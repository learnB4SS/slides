<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Bayesian Data  Analysis  for  Speech Sciences</title>
    <meta charset="utf-8" />
    <meta name="author" content="Timo Roettger, Stefano Coretta and Joseph Casillas" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://learnb4ss.github.io/b4ss-theme/css/b4ss.css" type="text/css" />
    <link rel="stylesheet" href="https://learnb4ss.github.io/b4ss-theme/css/b4ss-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Bayesian Data <br>Analysis<br> for <br>Speech Sciences
## More on priors
### Timo Roettger, Stefano Coretta and Joseph Casillas
### LabPhon workshop
### 2021/07/06 (updated: 2021-07-03)

---






class: center middle

![](img/informativity.png)

???

Priors can convey different amounts of prior knowledge, or information. This is called "informativity".

---

class: center middle

![](img/informativity-scale.png)

???

Informativity is a scale: from the least to the greatest amount of information.

Note that the scale is relative, not absolute.

---

class: center middle

![](img/informativity-scale-types.png)

???

Based on the scale, we can identify three types of priors:

- Uninformative priors: virtually no prior knowledge/information is added to the model. These are also called "flat" priors, because the distribution is flat (all values have the same probability). No influence on the posterior.

- Weakly informative priors: some prior knowledge/information is added to the model, but it is vague or at least less informative than what the actual prior knowledge is.

- Strongly informative priors: most or all of the prior knowledge/information is added to the model. This have the strongest influence on the posterior.

---

# Prior informativity

&lt;img src="index_files/figure-html/f0-prior-1.png" width="800px" style="display: block; margin: auto;" /&gt;

???

Examples of priors with different degrees of informativity in relation to the mean f0.


---

class: center middle

![](img/regularising.png)

???

Regularising priors are priors centered on 0 (i.e. with mean = 0). These priors are help with model estimation and safe-guard against extreme effects.

---

by [Kristoffer Magnusson](https://rpsychologist.com/)

&lt;iframe src="https://rpsychologist.com/d3/bayes/" style="border:none;" width="100%" height="80%"&gt;

???

Here we can visualise the effect of the prior on the posterior.

---

# Recommendations

.bg-washed-blue.b--black.ba.bw2.br3.shadow-5.ph4.mt2[
Use **regularising priors**.

- Prior mean = 0.
]

.bg-washed-blue.b--black.ba.bw2.br3.shadow-5.ph4.mt2[
Use **weakly informative priors**.

- Prior standard deviation as large as it makes sense.
]

---

# Prior predictive checks


```r
my_priors &lt;- c(
  prior(normal(0, 15), class = Intercept),
  prior(normal(0, 10), class = b, coef = attitudepol),
  prior(cauchy(0, 1), class = sigma)
)

b_mod_01_pripc &lt;- brm(
  articulation_rate ~ attitude,
  prior = my_priors,
  sample_prior = "only",
  data = polite,
  file = here::here("assets/b_mod_01_pripc")
)
```

???

When choosing priors it's important to check that they are weakly informative enough, but not too weakly informative.

You can run prior predictive checks using the same code as you would use when fitting the model, but with the argument `sample_prior = "only"`.

This code will run the model sampling values from the priors.

---

# Prior predictive checks


```r
conditional_effects(b_mod_01_pripc)
```

&lt;img src="index_files/figure-html/prior-pred-checks-plot-1.png" width="800px" style="display: block; margin: auto;" /&gt;

???

You can now plot the model predictions based on the priors with `conditional_effects()`. (You can use this function with a full model too!)

Remember yesterday we were wondering about negative values (articulation rate cannot be negative)? That is because, in fact, articulation rate does not follow a normal/Gaussian distribution.

Instead, we can use a log-normal distribution as the family of the outcome variable.

---

# BRM with non-Gaussian distributions


```r
my_priors &lt;- c(
  prior(normal(0, 3), class = Intercept),
  prior(normal(0, 1), class = b, coef = attitudepol),
  prior(cauchy(0, 0.1), class = sigma)
)

b_mod_02_pripc &lt;- brm(
  articulation_rate ~ attitude,
  prior = my_priors,
  sample_prior = "only",
  data = polite,
  family = lognormal(),
  file = here::here("assets/b_mod_02_pripc")
)
```

???

This is just a quick example with `family = lognormal()`. Note that priors have to be specified on the log-scale and that the posterior will also be on the log scale.

Unfortunately we don't have time to go into details (it would need a workshop on its own!), but if you used logistic regressions before, you can use your knowledge to set priors and interpret the model output.

The same concepts we covered with priors for `family = gaussian()` apply to other distributions.

---

# BRM with non-Gaussian distributions


```r
conditional_effects(b_mod_02_pripc)
```

&lt;img src="index_files/figure-html/prior-pred-checks-log-normal-plot-1.png" width="800px" style="display: block; margin: auto;" /&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://learnb4ss.github.io/b4ss-theme/js/b4ss_xaringan.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
